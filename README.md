# PLP

This is a modified copy of Caleb Belth's PLP model. Directories  ```data/```,  ```src/```, and  ```test/``` are Belth's. Everything else is mine.

# Logical Phonology PLP

The directory ```lp_src``` presents the **in progress** work on adapting PLP to induce Logical Phonology rules. The core idea is to take the segment-based mappings that PLP produces and transform them into Logical Phonology rules that one is able to generalize over. 

## The implementation

The directory ```lp_src/``` contains all files that ```src/``` does plus files ```LPgrammar.py```, ```lp_plp.py```, and ```generator.py```. The first one presents an implementation of a Logical Phonology-style grammar. The second one presents a generalization model that gets from segment-based mappings PLP to conservatively generalized Logical Phonology rules. The last one generated a dataset found in ```lp_data/generated_data/data.txt```

### LPgrammar.py

In the ```LPgrammar.py``` file, I implement the necessary data structures for an implementation of Logical Phonology: a set of valued features, a Natural Class, a phonological rule, a phonetics-phonology interface (construed as a mapping between (IPA) symbols and sets of valued features), and a grammar (that consists of rules and an interface). The code in ```LPgrammar.py``` contains commentary that should help in its comprehension.

There are a number of limitations that do not make it a full LP implementation. First, there is no implementation of segment deletion / segment insertion. Second, there is no implementation of alpha-notation.

### LP_PLP

In the ```lp_plp.py``` file, I implement the first attempt at taking the segment to segment mappings generated by PLP and making them into generalized Logical Phonology rules. The procedure consists of, essentially, two steps. The first step is to take a segment to segment mapping of the form ```segment1 -> segment2 / segment3_segment4``` and transform that into a Logical Phonology rules. 

The second step is to generalize the existing segment to segment mappings. The step is implemented in the following way: two rules that incur the same change are unified by taking an intersection of the natural classes they refer to (target, left context, and right context). Then, the unified rule is checked for productivity. That step is repeated until no unification of the rules that incur the same change is possible. 

An important note is that this procedure results in maximal specification of the rules (in line with Gorman, Reiss 2024): because no feature redundancies are filtered from the resulting phonological rule.  

Finally, the learner is static: no implementation of incremental training is there yet. 

## The working example

Starting ```lp_src/my_example``` (which applies LP_PLP to ```lp_data/generated_data/data.txt```) results in 4 rules. Importantly, given that the segment V, which is underspecified for voicing, is present in the input, the model both generalizes the feature insertion step of regressive voicing assimilation to include underspecified segments and generalizes the feature insertion step of regressive voicing assimilation with the default +voice insertion process used to generate the data (see ```lp_src/generator.py```).

Note: the algorithm is rather slow and takes a while. 

The result can be found in ```lp_data/generated_data/description.txt```. As shown in ```lp_data/generated_data/description_plp.txt```, PLP fails to converge and treats the V segment in a special way (as expected).

## Current limitations

As it stands, the Logical Phonology PLP cannot account for any process interactions (due to the simplicity of the ```order_rules()``` method) and intrinsic limitations of PLP (discussed by Belth). For example, in ```lp_data/generated_data_FD/``` one finds an attempt to apply LP PLP to fully Russian-style system with (i) /V/; (ii) regressive voicing assimilation; (iii) final devoicing. As it stands, the model incorrectly generalizes the -voice insertion rule at the cost of having two +voi insertion rules. I should note, however, that the model correctly generalizes the +voice deleting rule in the word final position.